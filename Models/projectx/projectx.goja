model projectx {

server Server {
	public ProgramManager programManager;
	public ModuleManager moduleManager;
	public StudyGroupManager groupManager;
	public StudentManager studentManager;
/* Programm erstellen -> Attribute: name */
	void createProgram @@ Programm_erstellen (String name);
/* Fehler aus dem Error-Screen entfernen -> Attribute: error */
	void removeError @@ Error_entfernen (ErrorDisplay error);
/* Modul zum jeweiligen Programm hinzufügen -> Attribute: program, module */
	void addModuleToProg @@ Modul_hinzufügen (Program program, ModuleAbstract module {moduleManager;modules});
/* Modul zur jeweiligen Gruppe hinzufügen -> Attribute: Modulgruppe group, module */
	void addModuleToGroup @@ Modul_hinzufügen (ModuleGroup group, ModuleAbstract module {moduleManager;modules});
/* Modul erstellen -> Attibute: Modulart type, name */
	void createModule @@ Modul_erstellen (ModuleAbstractSUBTYPEName type, String name);
/* Unit zu ModulMitUnits hinzufügen -> Attribute: Modulbezeichnung module, name, creditPoints */
	void addUnit @@ Unit_hinzufügen (ModuleWithUnits module, String name, Fraction creditPoints);
/* Menge der erreichbaren creditPoints der Unit ändern -> Attribute: Unitbezeichnung unit, creditPoints */
	void changeCPOnUnit @@ CP_ändern (Unit unit, Fraction creditPoints);
/* Menge der erreichbaren creditpoints des Moduls ändern -> Attribute: Modulbezeichnung module, creditPoints */
	void changeCPOnModule @@ CP_ändern (ModuleAtomar module, Fraction creditPoints);
/* Neue Studiengruppe eröffnen -> Attribute: program, name */
	void startStudyGroup @@ Studiengruppe_eröffnen (Program program, String name);
/* CreditPoints der einzelnen Units ändern, ohne die Gesamtmenge der CPs für das Modul zu verändern -> Attribute: module, fromUnit, ToUnit, creditPoints */
	void swapCPonModuleWithUnits @@ CP_der_Units_ändern (ModuleWithUnitsSGroup module, UnitSGroup fromUnit @@ Von_Unit{;module;units}, UnitSGroup ToUnit @@ Zu_Unit{;module;units}, Fraction creditPoints);
/* Anlegen eines neuen Studenten -> Attribute: firstName, lastName, birthDate */
	void createStudent @@ Student_erstellen (String firstName, String lastName, Date birthDate);
/* Studenten zu Studiengruppe hinzufügen -> Attribute: group, student */
	void addStudentToGroup @@ Student_hinzufügen (StudyGroup group, Student student {studentManager;students});
/* Gewähltes Notensystem ändern [Z.B. 1,0/1,3/...] -> Attribute: module, gradeSystem */
	void changeGradeSystem @@ Notensystem_ändern (ModuleAtomar module, GradeSystemSUBTYPEName gradeSystem);
}

																									/* Manager Klassen */
class ProgramManager {
	public Program ** programs;
/* Programm erstellen -> Attribute: name */
	active void createProgram(String name) throws AlreadyExistsInParentException;
/* Modul zum Programm hinzufügen -> Attribute: program, module */
	active void addModuleToProg(Program program, ModuleAbstract module) throws CycleException, AlreadyExistsInParentException;
}

class ModuleManager {
	public ModuleAbstract ** modules;
/* Modul erstellen -> Attribute: type, name */
	active void createModule(ModuleAbstractSUBTYPEName type, String name) throws AlreadyExistsInParentException;
/* Modul zu einer Gruppe hinzufügen -> Attribute: group, module */
	active void addModuleToGroup(ModuleGroup group, ModuleAbstract module) throws CycleException, AlreadyExistsInParentException;
/* Unit hinzufügen -> Attribute: module, name, creditPoints */
	active void addUnit(ModuleWithUnits module, String name, Fraction creditPoints) throws CycleException, AlreadyExistsInParentException;
/* Credit Points einer Unit verändern -> Attribute: unit, creditPoints */
	active void changeCPOnUnit(Unit unit, Fraction creditPoints);
/* Credit Points eines Modul verändern -> Attribute: module, creditPoints */
	active void changeCPOnModule(ModuleAtomar module, Fraction creditPoints);
/* Notensystem verändern -> Attribute: module, gradeSystem */
	active void changeGradeSystem (ModuleAtomar module, GradeSystemSUBTYPEName gradeSystem) throws invalidGradeSysteException;
}

class StudyGroupManager {
	public StudyGroup ** groups;
/* Eine neue Studiengruppe eröffnen -> Attribute: program, name */
	active void startStudyGroup(Program program, String name) throws UserException;	
/* Credit Points zwischen zwei Unit verschieben -> Attribute: module, fromUnit, toUnit, creditPoints */
	active void swapCPonModuleWithUnits ## sCPonMWU(ModuleWithUnitsSGroup module, UnitSGroup fromUnit, UnitSGroup ToUnit, Fraction creditPoints) throws UnitSwapException;
}

class StudentManager {
	public Student ** students;
/* Student erstellen -> Attribute: firstName, lastName, birthDate */
	active void createStudent (String firstName, String lastName, Date birthDate);
/* Student zu einer Studiengruppe zuordnen -> Attribute: group, student */
	active void addStudentToGroup ## add_S2G (StudyGroup group, Student student) throws UserException;
}

																			/* Aufbau eines Studienprogramms */
hierarchy programHierarchy;

/** Program stellt das Studienprogramm dar, für das sich ein Student anmelden kann */
class Program {
	public ModuleAbstract ** modules hierarchy programHierarchy;
	public prior indexed String name;
	/* wird als derived attribute aus den Attributen der Module errechnet. */
	public derived Fraction creditPoints;
	public no-view GradeSystem gradeSystem;
	/* Ermöglicht das Hinzufügen von Modulen und Modulgruppen zu einem Studienprogramm. Wirft eine Exception, falls Modul/Modulgruppe bereits in Studienprogramm vorhanden ist. */
	void addModule(ModuleAbstract module) throws CycleException, AlreadyExistsInParentException;
	ProgramSGroup copyForStudyGroup() throws UserException;
}

/** Definiert das abstrakte Modul mit den Kernattributen, welche an die Children weitervererbt werden. Attribute: name, creditPoints, gradeSystem */
abstract string-factory class ModuleAbstract {
	public prior indexed String name;
	public abstract derived Fraction creditPoints;
	public no-view GradeSystem gradeSystem;
	abstract ModuleAbstractSGroup copyForStudyGroup() throws UserException;
}

/** Definiert die Modul-Gruppe als Erweiterung des abstrakten Moduls */
class ModuleGroup @@ Gruppe extends ModuleAbstract {
	public ModuleAbstract ** modules hierarchy programHierarchy;
	/* Ermöglicht das Hinzufügen von Modulen zur jeweiligen Modul-Gruppe. Wirft Exception, falls Modul mit identischem Namen bereits in Modulgruppe vorhanden ist. */
	void addModule(ModuleAbstract module) throws CycleException, AlreadyExistsInParentException;
}

/** Definiert das atomare Modul als Erweiterung des abstrakten Moduls. Das atomare Modul hat selbst keine Units. */
class ModuleAtomar @@ Atomar extends ModuleAbstract {
	Fraction ownCreditPoints;
	/* Ermöglicht das Ändern der Creditpoints, welche durch das erfolgreiche Absolvieren des Moduls erreicht werden können */
	void changeCPOnModule(Fraction creditPoints);
	/* Ermöglicht das Ändern des Notensystems, nach welchem das Modul bewertet wird */
	void changeGradeSystem (GradeSystem gradeSystem);
}

/** Definiert das Modul, welches sich aus Units zusammensetzt, als Erweiterung des abstrakten Moduls */
class ModuleWithUnits @@ Mit_Units extends ModuleAbstract {
	public Unit ** units hierarchy programHierarchy;
	/* Ermöglicht das Hinzufügen von Unit zu ModuleWithUnits und erwartet Name & creditPoints. Wirft eine Exception, falls Unit mit identischem Name bereits in Modul vorhanden ist. */
	void addUnit(String name, Fraction creditPoints) throws CycleException, AlreadyExistsInParentException;
}

/** Definiert die Unit, welche als Teilleistungen in ModuleWithUnits eingebunden werden */
class Unit {
	public prior String name;
	public prior Fraction creditPoints;
	public no-view GradeSystem gradeSystem;
	/* Ermöglicht das Ändern der CreditPoints, welche durch das absolvieren der Unit erreicht werden können */
	void changeCPOnUnit(Fraction creditPoints);
	UnitSGroup copyForStudyGroup() throws UserException;
}

																			/* Aufbau der Studiengruppen */
class StudyGroup {
	public prior indexed String name;
	public-write ProgramSGroup program;
	public symmetric (no-view parentGroup) Student ** students;
}

hierarchy programHierarchySGroup ## pro_hier_s;

class ProgramSGroup {
	public ModuleAbstractSGroup ** modules hierarchy programHierarchySGroup;
	public derived String name;
	public derived Fraction creditPoints;
	prior Program programCopy;
	void addModule(ModuleAbstractSGroup module) throws CycleException;
	ProgramStudent copyForStudent() throws UserException;
}

abstract string-factory class ModuleAbstractSGroup ## m_abstr_gr {
	public derived String name;
	public abstract derived Fraction creditPoints;		
	prior ModuleAbstract moduleCopy;
	abstract ModuleAbstractStudent copyForStudent() throws UserException;
}

class ModuleGroupSGroup extends ModuleAbstractSGroup {
	public ModuleAbstractSGroup ** modules hierarchy programHierarchySGroup;
	void addModule(ModuleAbstractSGroup module) throws CycleException;
}

class ModuleAtomarSGroup extends ModuleAbstractSGroup {
	prior Fraction ownCreditPoints;
}

class ModuleWithUnitsSGroup ## m_unit_gr extends ModuleAbstractSGroup {
	public UnitSGroup ** units hierarchy programHierarchySGroup;
	void addUnit(UnitSGroup unit) throws CycleException;
	void swapCPonModuleWithUnits ## sCPonMWU(UnitSGroup fromUnit, UnitSGroup ToUnit, Fraction creditPoints) throws UnitSwapException;
}

class UnitSGroup {
	public derived String name;
	prior Unit unitCopy;
	public prior Fraction creditPoints;
	void addCP(Fraction creditPoints);
	void subCP(Fraction creditPoints) throws UnitSwapException;
	UnitStudent copyForStudent() throws UserException;
}


		
																	/* Aufbau der Studenten */
/** Initialisiert das Objekt Student und die dazugehörigen Attribute des Studenten */
class Student {
	public prior String firstName;
	public prior String lastName;
	public prior Date birthDate;
	public derived Integer matrNr;
	/* Authorisiert ProgramStudent das Objekt Student mit Schreibzugriff */																																																// <- Ist das korrekt?
	public-write ProgramStudent program;
}

hierarchy programHierarchyStudent ## pr_hier_std;

class ProgramStudent {
	public ModuleAbstractStudent ** modules hierarchy programHierarchyStudent;
	public derived String name;
	public derived Fraction creditPoints;
	prior ProgramSGroup programCopy;
	void addModule(ModuleAbstractStudent module) throws CycleException;
}

abstract string-factory class ModuleAbstractStudent ## m_abstr_st {
	prior ModuleAbstractSGroup moduleCopy;
	public derived String name;
	public derived Fraction creditPoints;
}

class ModuleGroupStudent extends ModuleAbstractStudent {
	public ModuleAbstractStudent ** modules hierarchy programHierarchyStudent;
	void addModule(ModuleAbstractStudent module) throws CycleException;
}

class ModuleAtomarStudent ## m_atom_stud extends ModuleAbstractStudent {
}

class ModuleWithUnitsStudent ## m_unit_stud extends ModuleAbstractStudent {
	public UnitStudent ** units hierarchy programHierarchyStudent;
	void addUnit(UnitStudent unit) throws CycleException;
}

class UnitStudent {
	prior UnitSGroup unitCopy;
	public derived String name;
	public derived Fraction creditPoints;
}

																																			/* Noten */

/** Definiert das Notensystem mit den vordefinierten Notensystemarten */
abstract string-factory class GradeSystem (TenthGrade @@ Zehntelnoten, ThirdGrade @@ Drittelnoten, SimpleGrade @@ Einfach) { }

																												/* Exceptions */
exception UnitSwapException{}
exception AlreadyExistsInParentException{}
/** Exception wird geworfen, wenn bei Erstellung oder Modifizierung des Moduls/der Unit ein nicht vorgesehenes Notensystem gewählt wird */
exception invalidGradeSysteException{}

}

